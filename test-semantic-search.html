<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Search Test - Noctua Forest</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .search-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .result {
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #F58220;
            background-color: #f9f9f9;
        }
        .score {
            font-weight: bold;
            color: #F58220;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Semantic Search Test</h1>
        <p>Test the semantic search functionality with emotional and situational queries.</p>
        
        <input type="text" id="searchInput" class="search-input" placeholder="Try: 'sad breakup book' or 'inspiring career story' or 'quick escape read'">
        
        <div id="results"></div>
    </div>

    <script type="module">
        // Import the semantic search functions
        import { extractSemanticTags } from './forest-discovery.js';
        
        // Sample books for testing
        const sampleBooks = [
            {
                title: "The Midnight Library",
                author: "Matt Haig",
                blurb: "A story about depression, choices, and finding meaning in life",
                tags: ["depression", "choices", "meaning", "life"],
                reviewCount: 5
            },
            {
                title: "Atomic Habits",
                author: "James Clear",
                blurb: "A practical guide to building good habits and breaking bad ones",
                tags: ["habits", "productivity", "self-improvement", "success"],
                reviewCount: 8
            },
            {
                title: "The Seven Husbands of Evelyn Hugo",
                author: "Taylor Jenkins Reid",
                blurb: "A captivating story about love, ambition, and secrets in Hollywood",
                tags: ["love", "ambition", "secrets", "hollywood", "relationships"],
                reviewCount: 12
            },
            {
                title: "Educated",
                author: "Tara Westover",
                blurb: "A memoir about education, family, and breaking free from constraints",
                tags: ["education", "family", "memoir", "transformation"],
                reviewCount: 7
            },
            {
                title: "The Alchemist",
                author: "Paulo Coelho",
                blurb: "An inspiring tale about following your dreams and personal legend",
                tags: ["dreams", "inspiration", "journey", "philosophy"],
                reviewCount: 15
            }
        ];
        
        // Semantic search patterns (copied from forest-discovery.js)
        const semanticPatterns = {
            emotions: {
                'sad': ['sad', 'depressed', 'melancholy', 'heartbroken', 'grief', 'loss', 'tearful'],
                'happy': ['happy', 'joyful', 'uplifting', 'cheerful', 'inspiring', 'hopeful', 'positive'],
                'angry': ['angry', 'furious', 'rage', 'outraged', 'frustrated', 'irritated'],
                'scared': ['scared', 'frightened', 'terrified', 'anxious', 'worried', 'nervous'],
                'excited': ['excited', 'thrilled', 'energized', 'pumped', 'enthusiastic'],
                'calm': ['calm', 'peaceful', 'serene', 'relaxed', 'tranquil', 'zen']
            },
            situations: {
                'breakup': ['breakup', 'divorce', 'heartbreak', 'relationship', 'love', 'dating'],
                'career': ['career', 'job', 'work', 'professional', 'business', 'success'],
                'family': ['family', 'parent', 'child', 'mother', 'father', 'sibling'],
                'travel': ['travel', 'journey', 'adventure', 'explore', 'vacation', 'trip'],
                'health': ['health', 'illness', 'recovery', 'medical', 'wellness', 'fitness'],
                'education': ['school', 'college', 'university', 'learning', 'student', 'education']
            },
            preferences: {
                'quick': ['quick', 'fast', 'short', 'breezy', 'light', 'easy'],
                'deep': ['deep', 'complex', 'thoughtful', 'philosophical', 'intellectual'],
                'escapist': ['escape', 'fantasy', 'adventure', 'magical', 'otherworldly'],
                'realistic': ['realistic', 'contemporary', 'modern', 'real-life', 'authentic']
            }
        };
        
        function extractSemanticTags(text) {
            const tags = [];
            const lowerText = text.toLowerCase();
            
            Object.entries(semanticPatterns).forEach(([category, patterns]) => {
                Object.entries(patterns).forEach(([tag, keywords]) => {
                    if (keywords.some(keyword => lowerText.includes(keyword))) {
                        tags.push(tag);
                    }
                });
            });
            
            return tags;
        }
        
        function semanticSearch(books, query) {
            const searchTerms = query.toLowerCase().split(/\s+/);
            const queryTags = extractSemanticTags(query);
            
            return books.filter(book => {
                let score = 0;
                
                // Direct text matches
                if (book.title.toLowerCase().includes(query.toLowerCase())) score += 10;
                if (book.author.toLowerCase().includes(query.toLowerCase())) score += 8;
                
                // Semantic tag matching
                if (queryTags.length > 0) {
                    const bookContent = [
                        book.title,
                        book.author,
                        book.blurb || '',
                        ...(book.tags || [])
                    ].join(' ').toLowerCase();
                    
                    const bookTags = extractSemanticTags(bookContent);
                    const matchingTags = queryTags.filter(tag => bookTags.includes(tag));
                    score += matchingTags.length * 5;
                }
                
                // Keyword matching
                searchTerms.forEach(term => {
                    if (book.title.toLowerCase().includes(term)) score += 3;
                    if (book.author.toLowerCase().includes(term)) score += 2;
                    if (book.blurb && book.blurb.toLowerCase().includes(term)) score += 2;
                    if (book.tags && book.tags.some(tag => tag.toLowerCase().includes(term))) score += 1;
                });
                
                // Community validation
                if (book.reviewCount > 0) {
                    score += Math.min(book.reviewCount * 0.5, 5);
                }
                
                return score > 0;
            }).sort((a, b) => {
                const scoreA = calculateSemanticScore(a, query, queryTags);
                const scoreB = calculateSemanticScore(b, query, queryTags);
                return scoreB - scoreA;
            });
        }
        
        function calculateSemanticScore(book, query, queryTags) {
            let score = 0;
            const queryLower = query.toLowerCase();
            
            if (book.title.toLowerCase().includes(queryLower)) score += 10;
            if (book.author.toLowerCase().includes(queryLower)) score += 8;
            
            if (queryTags.length > 0) {
                const bookContent = [
                    book.title,
                    book.author,
                    book.blurb || '',
                    ...(book.tags || [])
                ].join(' ').toLowerCase();
                
                const bookTags = extractSemanticTags(bookContent);
                const matchingTags = queryTags.filter(tag => bookTags.includes(tag));
                score += matchingTags.length * 5;
            }
            
            if (book.reviewCount > 0) {
                score += Math.min(book.reviewCount * 0.5, 5);
            }
            
            return score;
        }
        
        // Test the search
        const searchInput = document.getElementById('searchInput');
        const resultsDiv = document.getElementById('results');
        
        function performSearch() {
            const query = searchInput.value.trim();
            if (!query) {
                resultsDiv.innerHTML = '<p>Enter a search query to test semantic search.</p>';
                return;
            }
            
            const results = semanticSearch(sampleBooks, query);
            const queryTags = extractSemanticTags(query);
            
            let html = `<h3>Search Results for: "${query}"</h3>`;
            html += `<p><strong>Detected semantic tags:</strong> ${queryTags.join(', ') || 'none'}</p>`;
            
            if (results.length === 0) {
                html += '<p>No books found matching your query.</p>';
            } else {
                results.forEach((book, index) => {
                    const score = calculateSemanticScore(book, query, queryTags);
                    html += `
                        <div class="result">
                            <h4>${book.title} by ${book.author}</h4>
                            <p>${book.blurb}</p>
                            <p><strong>Tags:</strong> ${book.tags.join(', ')}</p>
                            <p><strong>Reviews:</strong> ${book.reviewCount} | <span class="score">Score: ${score}</span></p>
                        </div>
                    `;
                });
            }
            
            resultsDiv.innerHTML = html;
        }
        
        searchInput.addEventListener('input', performSearch);
        
        // Initial test
        performSearch();
    </script>
</body>
</html>
